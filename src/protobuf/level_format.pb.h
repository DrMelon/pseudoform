// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_level_5fformat_2eproto__INCLUDED
#define PROTOBUF_level_5fformat_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>

namespace levelFormat {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_level_5fformat_2eproto();
void protobuf_AssignDesc_level_5fformat_2eproto();
void protobuf_ShutdownFile_level_5fformat_2eproto();

class vec3;
class quat;
class genericPropInfo;
class portalInfo;
class triggerInfo;
class entity;
class level;

// ===================================================================

class vec3 : public ::google::protobuf::Message {
 public:
  vec3();
  virtual ~vec3();

  vec3(const vec3& from);

  inline vec3& operator=(const vec3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const vec3& default_instance();
  void Swap(vec3* other);

  // implements Message ----------------------------------------------

  vec3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const vec3& from);
  void MergeFrom(const vec3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;

  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_level_5fformat_2eproto();
  friend void protobuf_AssignDesc_level_5fformat_2eproto();
  friend void protobuf_ShutdownFile_level_5fformat_2eproto();

  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }

  void InitAsDefaultInstance();
  static vec3* default_instance_;
};
// -------------------------------------------------------------------

class quat : public ::google::protobuf::Message {
 public:
  quat();
  virtual ~quat();

  quat(const quat& from);

  inline quat& operator=(const quat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const quat& default_instance();
  void Swap(quat* other);

  // implements Message ----------------------------------------------

  quat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const quat& from);
  void MergeFrom(const quat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // optional float w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline float w() const;
  inline void set_w(float value);

 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;

  float x_;
  float y_;
  float z_;
  float w_;
  friend void  protobuf_AddDesc_level_5fformat_2eproto();
  friend void protobuf_AssignDesc_level_5fformat_2eproto();
  friend void protobuf_ShutdownFile_level_5fformat_2eproto();

  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }

  void InitAsDefaultInstance();
  static quat* default_instance_;
};
// -------------------------------------------------------------------

class genericPropInfo : public ::google::protobuf::Message {
 public:
  genericPropInfo();
  virtual ~genericPropInfo();

  genericPropInfo(const genericPropInfo& from);

  inline genericPropInfo& operator=(const genericPropInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const genericPropInfo& default_instance();
  void Swap(genericPropInfo* other);

  // implements Message ----------------------------------------------

  genericPropInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const genericPropInfo& from);
  void MergeFrom(const genericPropInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string script = 1;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 1;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();

  // optional .levelFormat.vec3 position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::levelFormat::vec3& position() const;
  inline ::levelFormat::vec3* mutable_position();

  // optional .levelFormat.quat rotation = 3;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 3;
  inline const ::levelFormat::quat& rotation() const;
  inline ::levelFormat::quat* mutable_rotation();

  // optional .levelFormat.vec3 scale = 4;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 4;
  inline const ::levelFormat::vec3& scale() const;
  inline ::levelFormat::vec3* mutable_scale();

  // optional float mass = 5;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 5;
  inline float mass() const;
  inline void set_mass(float value);

  // optional bool collidable = 6;
  inline bool has_collidable() const;
  inline void clear_collidable();
  static const int kCollidableFieldNumber = 6;
  inline bool collidable() const;
  inline void set_collidable(bool value);

 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;

  ::std::string* script_;
  static const ::std::string _default_script_;
  ::levelFormat::vec3* position_;
  ::levelFormat::quat* rotation_;
  ::levelFormat::vec3* scale_;
  float mass_;
  bool collidable_;
  friend void  protobuf_AddDesc_level_5fformat_2eproto();
  friend void protobuf_AssignDesc_level_5fformat_2eproto();
  friend void protobuf_ShutdownFile_level_5fformat_2eproto();

  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }

  void InitAsDefaultInstance();
  static genericPropInfo* default_instance_;
};
// -------------------------------------------------------------------

class portalInfo : public ::google::protobuf::Message {
 public:
  portalInfo();
  virtual ~portalInfo();

  portalInfo(const portalInfo& from);

  inline portalInfo& operator=(const portalInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const portalInfo& default_instance();
  void Swap(portalInfo* other);

  // implements Message ----------------------------------------------

  portalInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const portalInfo& from);
  void MergeFrom(const portalInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string connection = 1;
  inline bool has_connection() const;
  inline void clear_connection();
  static const int kConnectionFieldNumber = 1;
  inline const ::std::string& connection() const;
  inline void set_connection(const ::std::string& value);
  inline void set_connection(const char* value);
  inline void set_connection(const char* value, size_t size);
  inline ::std::string* mutable_connection();

 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;

  ::std::string* connection_;
  static const ::std::string _default_connection_;
  friend void  protobuf_AddDesc_level_5fformat_2eproto();
  friend void protobuf_AssignDesc_level_5fformat_2eproto();
  friend void protobuf_ShutdownFile_level_5fformat_2eproto();

  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }

  void InitAsDefaultInstance();
  static portalInfo* default_instance_;
};
// -------------------------------------------------------------------

class triggerInfo : public ::google::protobuf::Message {
 public:
  triggerInfo();
  virtual ~triggerInfo();

  triggerInfo(const triggerInfo& from);

  inline triggerInfo& operator=(const triggerInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const triggerInfo& default_instance();
  void Swap(triggerInfo* other);

  // implements Message ----------------------------------------------

  triggerInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const triggerInfo& from);
  void MergeFrom(const triggerInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string on_enter = 1;
  inline bool has_on_enter() const;
  inline void clear_on_enter();
  static const int kOnEnterFieldNumber = 1;
  inline const ::std::string& on_enter() const;
  inline void set_on_enter(const ::std::string& value);
  inline void set_on_enter(const char* value);
  inline void set_on_enter(const char* value, size_t size);
  inline ::std::string* mutable_on_enter();

  // optional string on_exit = 2;
  inline bool has_on_exit() const;
  inline void clear_on_exit();
  static const int kOnExitFieldNumber = 2;
  inline const ::std::string& on_exit() const;
  inline void set_on_exit(const ::std::string& value);
  inline void set_on_exit(const char* value);
  inline void set_on_exit(const char* value, size_t size);
  inline ::std::string* mutable_on_exit();

 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;

  ::std::string* on_enter_;
  static const ::std::string _default_on_enter_;
  ::std::string* on_exit_;
  static const ::std::string _default_on_exit_;
  friend void  protobuf_AddDesc_level_5fformat_2eproto();
  friend void protobuf_AssignDesc_level_5fformat_2eproto();
  friend void protobuf_ShutdownFile_level_5fformat_2eproto();

  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }

  void InitAsDefaultInstance();
  static triggerInfo* default_instance_;
};
// -------------------------------------------------------------------

class entity : public ::google::protobuf::Message {
 public:
  entity();
  virtual ~entity();

  entity(const entity& from);

  inline entity& operator=(const entity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const entity& default_instance();
  void Swap(entity* other);

  // implements Message ----------------------------------------------

  entity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const entity& from);
  void MergeFrom(const entity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();

  // optional .levelFormat.genericPropInfo generic_prop_info = 3;
  inline bool has_generic_prop_info() const;
  inline void clear_generic_prop_info();
  static const int kGenericPropInfoFieldNumber = 3;
  inline const ::levelFormat::genericPropInfo& generic_prop_info() const;
  inline ::levelFormat::genericPropInfo* mutable_generic_prop_info();

  // optional .levelFormat.portalInfo portal_info = 4;
  inline bool has_portal_info() const;
  inline void clear_portal_info();
  static const int kPortalInfoFieldNumber = 4;
  inline const ::levelFormat::portalInfo& portal_info() const;
  inline ::levelFormat::portalInfo* mutable_portal_info();

  // optional .levelFormat.triggerInfo trigger_info = 5;
  inline bool has_trigger_info() const;
  inline void clear_trigger_info();
  static const int kTriggerInfoFieldNumber = 5;
  inline const ::levelFormat::triggerInfo& trigger_info() const;
  inline ::levelFormat::triggerInfo* mutable_trigger_info();

 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;

  ::google::protobuf::uint32 type_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::levelFormat::genericPropInfo* generic_prop_info_;
  ::levelFormat::portalInfo* portal_info_;
  ::levelFormat::triggerInfo* trigger_info_;
  friend void  protobuf_AddDesc_level_5fformat_2eproto();
  friend void protobuf_AssignDesc_level_5fformat_2eproto();
  friend void protobuf_ShutdownFile_level_5fformat_2eproto();

  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }

  void InitAsDefaultInstance();
  static entity* default_instance_;
};
// -------------------------------------------------------------------

class level : public ::google::protobuf::Message {
 public:
  level();
  virtual ~level();

  level(const level& from);

  inline level& operator=(const level& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const level& default_instance();
  void Swap(level* other);

  // implements Message ----------------------------------------------

  level* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const level& from);
  void MergeFrom(const level& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .levelFormat.entity entities = 1;
  inline int entities_size() const;
  inline void clear_entities();
  static const int kEntitiesFieldNumber = 1;
  inline const ::google::protobuf::RepeatedPtrField< ::levelFormat::entity >& entities() const;
  inline ::google::protobuf::RepeatedPtrField< ::levelFormat::entity >* mutable_entities();
  inline const ::levelFormat::entity& entities(int index) const;
  inline ::levelFormat::entity* mutable_entities(int index);
  inline ::levelFormat::entity* add_entities();

  // optional string script = 2;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 2;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();

 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;

  ::google::protobuf::RepeatedPtrField< ::levelFormat::entity > entities_;
  ::std::string* script_;
  static const ::std::string _default_script_;
  friend void  protobuf_AddDesc_level_5fformat_2eproto();
  friend void protobuf_AssignDesc_level_5fformat_2eproto();
  friend void protobuf_ShutdownFile_level_5fformat_2eproto();

  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }

  void InitAsDefaultInstance();
  static level* default_instance_;
};
// ===================================================================


// ===================================================================


// ===================================================================

// vec3

// optional float x = 1;
inline bool vec3::has_x() const {
  return _has_bit(0);
}
inline void vec3::clear_x() {
  x_ = 0;
  _clear_bit(0);
}
inline float vec3::x() const {
  return x_;
}
inline void vec3::set_x(float value) {
  _set_bit(0);
  x_ = value;
}

// optional float y = 2;
inline bool vec3::has_y() const {
  return _has_bit(1);
}
inline void vec3::clear_y() {
  y_ = 0;
  _clear_bit(1);
}
inline float vec3::y() const {
  return y_;
}
inline void vec3::set_y(float value) {
  _set_bit(1);
  y_ = value;
}

// optional float z = 3;
inline bool vec3::has_z() const {
  return _has_bit(2);
}
inline void vec3::clear_z() {
  z_ = 0;
  _clear_bit(2);
}
inline float vec3::z() const {
  return z_;
}
inline void vec3::set_z(float value) {
  _set_bit(2);
  z_ = value;
}

// -------------------------------------------------------------------

// quat

// optional float x = 1;
inline bool quat::has_x() const {
  return _has_bit(0);
}
inline void quat::clear_x() {
  x_ = 0;
  _clear_bit(0);
}
inline float quat::x() const {
  return x_;
}
inline void quat::set_x(float value) {
  _set_bit(0);
  x_ = value;
}

// optional float y = 2;
inline bool quat::has_y() const {
  return _has_bit(1);
}
inline void quat::clear_y() {
  y_ = 0;
  _clear_bit(1);
}
inline float quat::y() const {
  return y_;
}
inline void quat::set_y(float value) {
  _set_bit(1);
  y_ = value;
}

// optional float z = 3;
inline bool quat::has_z() const {
  return _has_bit(2);
}
inline void quat::clear_z() {
  z_ = 0;
  _clear_bit(2);
}
inline float quat::z() const {
  return z_;
}
inline void quat::set_z(float value) {
  _set_bit(2);
  z_ = value;
}

// optional float w = 4;
inline bool quat::has_w() const {
  return _has_bit(3);
}
inline void quat::clear_w() {
  w_ = 0;
  _clear_bit(3);
}
inline float quat::w() const {
  return w_;
}
inline void quat::set_w(float value) {
  _set_bit(3);
  w_ = value;
}

// -------------------------------------------------------------------

// genericPropInfo

// optional string script = 1;
inline bool genericPropInfo::has_script() const {
  return _has_bit(0);
}
inline void genericPropInfo::clear_script() {
  if (script_ != &_default_script_) {
    script_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& genericPropInfo::script() const {
  return *script_;
}
inline void genericPropInfo::set_script(const ::std::string& value) {
  _set_bit(0);
  if (script_ == &_default_script_) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void genericPropInfo::set_script(const char* value) {
  _set_bit(0);
  if (script_ == &_default_script_) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void genericPropInfo::set_script(const char* value, size_t size) {
  _set_bit(0);
  if (script_ == &_default_script_) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* genericPropInfo::mutable_script() {
  _set_bit(0);
  if (script_ == &_default_script_) {
    script_ = new ::std::string;
  }
  return script_;
}

// optional .levelFormat.vec3 position = 2;
inline bool genericPropInfo::has_position() const {
  return _has_bit(1);
}
inline void genericPropInfo::clear_position() {
  if (position_ != NULL) position_->::levelFormat::vec3::Clear();
  _clear_bit(1);
}
inline const ::levelFormat::vec3& genericPropInfo::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::levelFormat::vec3* genericPropInfo::mutable_position() {
  _set_bit(1);
  if (position_ == NULL) position_ = new ::levelFormat::vec3;
  return position_;
}

// optional .levelFormat.quat rotation = 3;
inline bool genericPropInfo::has_rotation() const {
  return _has_bit(2);
}
inline void genericPropInfo::clear_rotation() {
  if (rotation_ != NULL) rotation_->::levelFormat::quat::Clear();
  _clear_bit(2);
}
inline const ::levelFormat::quat& genericPropInfo::rotation() const {
  return rotation_ != NULL ? *rotation_ : *default_instance_->rotation_;
}
inline ::levelFormat::quat* genericPropInfo::mutable_rotation() {
  _set_bit(2);
  if (rotation_ == NULL) rotation_ = new ::levelFormat::quat;
  return rotation_;
}

// optional .levelFormat.vec3 scale = 4;
inline bool genericPropInfo::has_scale() const {
  return _has_bit(3);
}
inline void genericPropInfo::clear_scale() {
  if (scale_ != NULL) scale_->::levelFormat::vec3::Clear();
  _clear_bit(3);
}
inline const ::levelFormat::vec3& genericPropInfo::scale() const {
  return scale_ != NULL ? *scale_ : *default_instance_->scale_;
}
inline ::levelFormat::vec3* genericPropInfo::mutable_scale() {
  _set_bit(3);
  if (scale_ == NULL) scale_ = new ::levelFormat::vec3;
  return scale_;
}

// optional float mass = 5;
inline bool genericPropInfo::has_mass() const {
  return _has_bit(4);
}
inline void genericPropInfo::clear_mass() {
  mass_ = 0;
  _clear_bit(4);
}
inline float genericPropInfo::mass() const {
  return mass_;
}
inline void genericPropInfo::set_mass(float value) {
  _set_bit(4);
  mass_ = value;
}

// optional bool collidable = 6;
inline bool genericPropInfo::has_collidable() const {
  return _has_bit(5);
}
inline void genericPropInfo::clear_collidable() {
  collidable_ = false;
  _clear_bit(5);
}
inline bool genericPropInfo::collidable() const {
  return collidable_;
}
inline void genericPropInfo::set_collidable(bool value) {
  _set_bit(5);
  collidable_ = value;
}

// -------------------------------------------------------------------

// portalInfo

// optional string connection = 1;
inline bool portalInfo::has_connection() const {
  return _has_bit(0);
}
inline void portalInfo::clear_connection() {
  if (connection_ != &_default_connection_) {
    connection_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& portalInfo::connection() const {
  return *connection_;
}
inline void portalInfo::set_connection(const ::std::string& value) {
  _set_bit(0);
  if (connection_ == &_default_connection_) {
    connection_ = new ::std::string;
  }
  connection_->assign(value);
}
inline void portalInfo::set_connection(const char* value) {
  _set_bit(0);
  if (connection_ == &_default_connection_) {
    connection_ = new ::std::string;
  }
  connection_->assign(value);
}
inline void portalInfo::set_connection(const char* value, size_t size) {
  _set_bit(0);
  if (connection_ == &_default_connection_) {
    connection_ = new ::std::string;
  }
  connection_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* portalInfo::mutable_connection() {
  _set_bit(0);
  if (connection_ == &_default_connection_) {
    connection_ = new ::std::string;
  }
  return connection_;
}

// -------------------------------------------------------------------

// triggerInfo

// optional string on_enter = 1;
inline bool triggerInfo::has_on_enter() const {
  return _has_bit(0);
}
inline void triggerInfo::clear_on_enter() {
  if (on_enter_ != &_default_on_enter_) {
    on_enter_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& triggerInfo::on_enter() const {
  return *on_enter_;
}
inline void triggerInfo::set_on_enter(const ::std::string& value) {
  _set_bit(0);
  if (on_enter_ == &_default_on_enter_) {
    on_enter_ = new ::std::string;
  }
  on_enter_->assign(value);
}
inline void triggerInfo::set_on_enter(const char* value) {
  _set_bit(0);
  if (on_enter_ == &_default_on_enter_) {
    on_enter_ = new ::std::string;
  }
  on_enter_->assign(value);
}
inline void triggerInfo::set_on_enter(const char* value, size_t size) {
  _set_bit(0);
  if (on_enter_ == &_default_on_enter_) {
    on_enter_ = new ::std::string;
  }
  on_enter_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* triggerInfo::mutable_on_enter() {
  _set_bit(0);
  if (on_enter_ == &_default_on_enter_) {
    on_enter_ = new ::std::string;
  }
  return on_enter_;
}

// optional string on_exit = 2;
inline bool triggerInfo::has_on_exit() const {
  return _has_bit(1);
}
inline void triggerInfo::clear_on_exit() {
  if (on_exit_ != &_default_on_exit_) {
    on_exit_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& triggerInfo::on_exit() const {
  return *on_exit_;
}
inline void triggerInfo::set_on_exit(const ::std::string& value) {
  _set_bit(1);
  if (on_exit_ == &_default_on_exit_) {
    on_exit_ = new ::std::string;
  }
  on_exit_->assign(value);
}
inline void triggerInfo::set_on_exit(const char* value) {
  _set_bit(1);
  if (on_exit_ == &_default_on_exit_) {
    on_exit_ = new ::std::string;
  }
  on_exit_->assign(value);
}
inline void triggerInfo::set_on_exit(const char* value, size_t size) {
  _set_bit(1);
  if (on_exit_ == &_default_on_exit_) {
    on_exit_ = new ::std::string;
  }
  on_exit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* triggerInfo::mutable_on_exit() {
  _set_bit(1);
  if (on_exit_ == &_default_on_exit_) {
    on_exit_ = new ::std::string;
  }
  return on_exit_;
}

// -------------------------------------------------------------------

// entity

// optional uint32 type = 1;
inline bool entity::has_type() const {
  return _has_bit(0);
}
inline void entity::clear_type() {
  type_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 entity::type() const {
  return type_;
}
inline void entity::set_type(::google::protobuf::uint32 value) {
  _set_bit(0);
  type_ = value;
}

// optional string name = 2;
inline bool entity::has_name() const {
  return _has_bit(1);
}
inline void entity::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& entity::name() const {
  return *name_;
}
inline void entity::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void entity::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void entity::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* entity::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional .levelFormat.genericPropInfo generic_prop_info = 3;
inline bool entity::has_generic_prop_info() const {
  return _has_bit(2);
}
inline void entity::clear_generic_prop_info() {
  if (generic_prop_info_ != NULL) generic_prop_info_->::levelFormat::genericPropInfo::Clear();
  _clear_bit(2);
}
inline const ::levelFormat::genericPropInfo& entity::generic_prop_info() const {
  return generic_prop_info_ != NULL ? *generic_prop_info_ : *default_instance_->generic_prop_info_;
}
inline ::levelFormat::genericPropInfo* entity::mutable_generic_prop_info() {
  _set_bit(2);
  if (generic_prop_info_ == NULL) generic_prop_info_ = new ::levelFormat::genericPropInfo;
  return generic_prop_info_;
}

// optional .levelFormat.portalInfo portal_info = 4;
inline bool entity::has_portal_info() const {
  return _has_bit(3);
}
inline void entity::clear_portal_info() {
  if (portal_info_ != NULL) portal_info_->::levelFormat::portalInfo::Clear();
  _clear_bit(3);
}
inline const ::levelFormat::portalInfo& entity::portal_info() const {
  return portal_info_ != NULL ? *portal_info_ : *default_instance_->portal_info_;
}
inline ::levelFormat::portalInfo* entity::mutable_portal_info() {
  _set_bit(3);
  if (portal_info_ == NULL) portal_info_ = new ::levelFormat::portalInfo;
  return portal_info_;
}

// optional .levelFormat.triggerInfo trigger_info = 5;
inline bool entity::has_trigger_info() const {
  return _has_bit(4);
}
inline void entity::clear_trigger_info() {
  if (trigger_info_ != NULL) trigger_info_->::levelFormat::triggerInfo::Clear();
  _clear_bit(4);
}
inline const ::levelFormat::triggerInfo& entity::trigger_info() const {
  return trigger_info_ != NULL ? *trigger_info_ : *default_instance_->trigger_info_;
}
inline ::levelFormat::triggerInfo* entity::mutable_trigger_info() {
  _set_bit(4);
  if (trigger_info_ == NULL) trigger_info_ = new ::levelFormat::triggerInfo;
  return trigger_info_;
}

// -------------------------------------------------------------------

// level

// repeated .levelFormat.entity entities = 1;
inline int level::entities_size() const {
  return entities_.size();
}
inline void level::clear_entities() {
  entities_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::levelFormat::entity >&
level::entities() const {
  return entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::levelFormat::entity >*
level::mutable_entities() {
  return &entities_;
}
inline const ::levelFormat::entity& level::entities(int index) const {
  return entities_.Get(index);
}
inline ::levelFormat::entity* level::mutable_entities(int index) {
  return entities_.Mutable(index);
}
inline ::levelFormat::entity* level::add_entities() {
  return entities_.Add();
}

// optional string script = 2;
inline bool level::has_script() const {
  return _has_bit(1);
}
inline void level::clear_script() {
  if (script_ != &_default_script_) {
    script_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& level::script() const {
  return *script_;
}
inline void level::set_script(const ::std::string& value) {
  _set_bit(1);
  if (script_ == &_default_script_) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void level::set_script(const char* value) {
  _set_bit(1);
  if (script_ == &_default_script_) {
    script_ = new ::std::string;
  }
  script_->assign(value);
}
inline void level::set_script(const char* value, size_t size) {
  _set_bit(1);
  if (script_ == &_default_script_) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* level::mutable_script() {
  _set_bit(1);
  if (script_ == &_default_script_) {
    script_ = new ::std::string;
  }
  return script_;
}


}  // namespace levelFormat

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

#endif  // PROTOBUF_level_5fformat_2eproto__INCLUDED
